# 리눅스 명령어 
---
### 목차
- top
- ps
- jobs
- kill
---
## 1.1 top 명령어 
###### top(table of processes) 명령어는 CPU 사용량, 메모리 사용량 등에 관한 정보를 실시간으로 출력하는 명령어이다. 
    $top
### 1.2 top 명령어 주요옵션
|옵션|설명|
|---|---|
|-d delay|지정한 시간(delay) 간격으로 정보를 출력|
|-n num|지정한 횟수(num) 만큼 정보를 출력|
|-p pid|지정한 프로세스 id(pid)의 정보만 출력|
### 1.3 top 실행 후 주요명령어
1. Shift + p : CPU 사용률 내림차순
2. Shift + m : 메모리 사용률 내림차순
3. Shift + t : 프로세스가 돌아가고 있는순
### 1.4 top 명령어 실행화면
![top 명령어 실행화면](https://www.dropbox.com/s/6nnakv6e4j2ojji/Screenshot%202018-07-18%2020.25.32.png?raw=1)
###### - 3:58 : 3시간 58분 전에 서버가 구동
###### - load average : 현재 시스템이 얼마나 일을 하는지를 나타냄. 3개의 숫자는 1분, 5분, 15분 간의 평균 실행/대기 중인 프로세스의 수. - CPU 코어수 보다 적으면 문제 없음
###### - Tasks : 프로세스 개수
###### - KiB Mem, Swap : 각 메모리의 사용량
###### - PR : 실행 우선순위
###### - VIRT, RES, SHR : 메모리 사용량 => 누수 check 가능
###### - S : 프로세스 상태(작업중, I/O 대기, 유휴 상태 등)

### VIRT, RES, SHR
###### 현재 프로세스가 사용하고 있는 메모리
##### VIRT
###### - 프로세스가 사용하고 있는 virtual memory의 전체 용량
###### - 프로세스에 할당된 가상 메모리 전체
###### - SWAP + RES
##### RES
###### - 현재 프로세스가 사용하고 있는 물리 메모리의 양
###### - 실제로 메모리에 올려서 사용하고 있는 물리 메모리
###### - 실제로 메모리를 쓰고 있는 RES가 핵심!
##### SHR
###### - 다른 프로세스와 공유하고 있는 shared memory의 양
###### - 예시로 라이브러리를 들 수 있음. 대부분의 리눅스 프로세스는 glibc라는 라이브러리를 참고하기에 이런 라이브러리를 공유 메모리에 올려서 사용
##### Memory Commit
###### - 프로세스가 커널에게 필요한 메모리를 요청하면 커널은 프로세스에 메모리 영역을 주고 실제로 할당은 하지 않지만 해당 영역을 프로세스에게 주었다는 것을 저장해둠
###### - 이런 과정을 Memory commit이라 부름
#### 프로세스 상태
##### SHR 옆에 있는 S 항목으로 볼 수 있음
###### - D : Uninterruptiable sleep. 디스크 혹은 네트워크 I/O를 대기
###### - R : 실행 중(CPU 자원을 소모)
###### - S : Sleeping 상태, 요청한 리소스를 즉시 사용 가능
###### - T : Traced or Stopped. 보통의 시스템에서 자주 볼 수 없는 상태
###### - Z : zombie. 부모 프로세스가 죽은 자식 프로세스


## 2.1 ps 명령어 
###### ps(Process Status) 명령어 현재 시스템 상에서 작동 중인 프로세스를 확인할 수 있는 명령어다.
    $ps [옵션]
> linux 에서는 여러 개의 프로세스가 동시에 실행되며, ps 명령어로 현재 실행되는 프로세스들의 정보를 얻을 수 있다.
> 또한 프로세스 중에서 CPU, 메모리 등을 많이 점유하고 있거나, 지나치게 많은 자식 프로세스를 생성하는 등 시스템 속도가 느려진 경우 ps 명령어로 시스템 오류를 감지할 수 있다.
### 2.2 ps 명령어 주요옵션
|옵션|설명|
|---|---|
|-a|세션 리더와 터미널과 연관이 없는 프로세스를 제외한 모든 프로세스를 출력|
|a|BSD 스타일로 터미널과 연관된 모든 프로세스(다른 유저의 프로세스도) 를 출력하거나, x 옵션과 함께 사용되어 모든 프로세스를 출력|
|-d|세션 리더를 제외한 모든 프로세스들을 출력|
|r|실행 프로세스만 출력|
|x|BSD 스타일로 혼자 사용되면 사용자에 의해 소유된 모든 프로세스 출력하며, a 옵션과 함께 사용되어 모든 프로세스 출력|
|-l|상세 내용을 함께 출력|
|-e|모든 프로세스 출력|
|-f|풀 포맷으로 목록을 출력|
|-h|메뉴 x (PID, TTY, STAT, TIME, CMD 등|
|-j|작업에 관련된 ID 를 출력|
|u|프로세스 실행 user, CPU, memory, usage, 상태 등 출력|
|f|프로세스 간 상속관계를 트리구조로 출력|
|n|사용자의 정보를 (모든 형식의 UID 와 GID 를 포함하여) 숫자로 표시|
|-w|출력결과를 생략하지 않고 넓게 출력|
### 2.3 ps 명령어 실행화면
![ps -ef 명령어 실행화면](https://postfiles.pstatic.net/MjAyMTA0MjVfMjQ0/MDAxNjE5MzQ0Nzk0NDU3.sV5NU5mf6Tg4j97sNOl7Y9KSfT6gZI-9ZRvSd3YnOlUg.8QpSoyjeBKfC9BfqkOOapEEXKkx4IuWseMuRzX3JY9Yg.PNG.tmk0429/ps_ef.png?type=w773)
> $ps -ef 출력화면
###### - USER(BSD),UID(System V) : 프로세스 소유자의 이름
###### - PID : 프로세스의 식별 번호
###### - PPID : 부모 프로세스의 PID
###### - %CPU : CPU 사용 비율의 추정치 (BSD)
###### - %MEM : Memory 사용 비율의 추정치(BSD)
###### - VSZ : K 단위 또는 페이지 단위의 가상 메모리 사용량
###### = RSS : 실제 메모리 사용량
###### - TTY : 프로세스와 연결된 터미널
###### - S (System V),STAT (BSD) : 현재 프로세스의 상태 코드
###### - TIME : 총 CPU 사용 시간
###### - COMMAND : 프로세스의 실행 명령행
###### - STIME : 프로세스가 시작된 시간 혹은 날짜
###### - C (System V),CP (BSD) : 짧은 기간 동안의 CPU 사용률
###### - F : 플래그
###### - RRI : 실제 실행 우선순위
###### - NI : nice 우선순위 번호

## 3.1 jobs 명령어 
###### 백그라운드로 실행 중인 프로세스나 현재 중지된 프로세스의 목록을 출력해 주는 명령어
    $jobs [옵션][job ID]
### 3.2 jobs 명령어 주요옵션
|옵션|설명|
|---|---|
|-l (소문자 L)|프로세스에 번호를 추가하여 출력|
|-p|각 프로세스 ID에 대해 한 행씩 출력|
|-n|프로세스 그룹 중에 대표 프로세스 ID를 출력|
|command|지정한 명령어를 실행|
### 3.3 jobs 명령어 백그라운드 작업 상태값
```
[15:51:12 oss]$ jobs
[1]   Stopped                 vi
[2]-  Stopped                 vi
[3]+  Stopped                 vi
```
ㄴ출력예시
###### - Running : 작업이 계속 진행중임
###### - Done : 작업이 완료되어 0을 반환
###### - Done(code) : 작업이 종료되었으며 0이 아닌 코드를 반환
###### - Stopped : 작업이 일시 중단
###### - Stopped(SIGTSTP) : SIGTSTP 시그널이 작업을 일시중단
###### - Stopped(SIGSTOP) : SIGSTOP 시그널이 작업을 일시중단
###### - Stopped(SIGTTIN) : SIGTTIN 시그널이 작업을 일시중단
###### - Stopped(SIGTTOU) : SIGTTOU 시그널이 작업을 일시중단
### 3.4 ps 명령어와 jobs 명령어의 차이점
###### - ps 명령어는 모든 프로세스의 목록을 보여주며, 사용자가 실행한 프로세스 또는 시스템 프로세스를 모두 포함한다. 반면에 jobs 명령어는 현재 쉘 세션에서 실행 중인 프로세스 목록만을 보여준다. 따라서 백그라운드에서 실행 중인 프로세스를 확인하려면 jobs 명령어를 사용해야 한다.
###### - 또한, ps 명령어는 더 자세한 정보를 제공하며, 필요한 옵션을 사용하여 원하는 결과를 얻을 수 있다. 반면에 jobs 명령어는 현재 프로세스의 상태만을 간단하게 보여주는 목적으로 사용된다.
###### - 이러한 차이점을 고려하여 상황에 맞게 각각의 명령어를 선택하여 사용하면 된다.


## 4.1 kill 명령어 
###### 프로세스에 시그널을 보내는 명령어
    $kill [옵션] <PID>
### 4.2 kill 명령어 옵션
|옵션|설명|
|---|---|
|-9|프로세스아이디(PID)를 직접 지정하여 종료시 사용된다|
|-l|신호(Signal)로 사용할 수 있는 신호(Signal) 이름들을 보여준다|
### 4.2 kill 명령어 주요Signal
|번호|Signal이름|Signal|의미|
|---|---|---|---|
|1|SIGHUP|HUP|hangup, 로그아웃등의 접속이 끊을 때 발생하는 신호(Signal)로 특정 실행 중인 프로그램이 사용하는 설정 파일을 변경시키고 변화된 내용을 적용할때 사용된다|
|SIGINT|INT|현재 작동중인 프로그램의 동작을 멈출때 사용되며, 일반적인 값은 <CTRL>+<c>|
|9|SIGKILL|KILL|프로그램을 무조건 종료할 경우 사용된다|
|11|SIGSEGV|SEGV|잘못된 메모리 관리시 생기는 Signal이다|
|15|
